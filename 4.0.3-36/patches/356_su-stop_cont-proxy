Goal:	When su process sits between parent and child shells, it should
	propagate STOPs from child to parent and CONTs from parent to child,
	otherwise e.g. bash's "suspend" command won't work.

Status wrt upstream: Fixed in upstream the same way, with slightly different
	code inside run_shell(), since 4.0.5

Notes:	Affects only operation with CLOSE_SESSIONS=yes. When it's set to "no",
	newgrp doesn't fork and create child process, it just calls exec(),
	so there won't be "newgrp" process between parent and child shells.

	SIGCHLD is handled implicitly by waitpid() when WUNTRACED flag is
	specified.
	
	SIGCONT is handled implicitly too, because it just resumes execution
	right after the point the code has been stopped -- in our case it's
	the next command after "raise(SIGSTOP)", which has been processed
	_synchronously_.
	
	Thus there's no need to set signal handlers for either SIGCHLD or
	SIGCONT, and code is much cleaner with this.
	
	Because waitpid() is now placed inside a loop, here are some comments
	about when the loop is broken:
	1. (wpid != pid && errno != EINTR) -- when waitpid() returns any error
	   except "interrupted by signal", i.e. wrong pid, wrong options etc.
	2. WIFEXITED
	3. WIFSIGNALED
	4. WCOREDUMP
	This _differs_ with Tomasz's in EINTR handling -- Tomasz's su will
	_exit_ on EINTR. This code won't. I suspect that it's not possible
	to be inerrupted _that way_ with e.g. SIGCHLD, but who knows...

	Closes: 314727
	(suspend command from su shell fails to return to parent shell)

Index: shadow-4.0.3/src/su.c
===================================================================
--- shadow-4.0.3.orig/src/su.c	2005-06-20 11:15:03.000000000 +0300
+++ shadow-4.0.3/src/su.c	2005-06-20 11:35:27.000000000 +0300
@@ -737,7 +737,7 @@
 	   around to close sessions */
 	if (getdef_bool("CLOSE_SESSIONS")) {
 		pid_t pid;
-		int status;
+		int status, wpid;
 
 		signal(SIGINT, SIG_IGN);
 		pid = fork();
@@ -754,7 +754,17 @@
 			signal(SIGINT, SIG_DFL);
 			break;
 		default: /* parent */
-			waitpid(pid, &status, 0);
+			do {
+				errno = 0;
+				wpid = waitpid(pid, &status, WUNTRACED);
+				if (wpid == pid && WIFSTOPPED(status)) {
+					/* stop when child stops */
+					raise(SIGSTOP);
+					/* wake child when resumed */
+					kill(pid, SIGCONT);
+				}
+			} while (wpid == pid && WIFSTOPPED(status)
+					|| wpid != pid && errno == EINTR);
 			/* now we are done using PAM */
 			pam_setcred(pamh, PAM_DELETE_CRED);
 			ret = pam_close_session(pamh, 0);

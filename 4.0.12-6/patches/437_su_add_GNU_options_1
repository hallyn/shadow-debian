Goal: First patch to switch to getopt.
      Still incomplete.
      Done:
       * selection of the shell (-s).
      Broken:
       * additional_args is set, but not used.
       * !doshell is broken (argv is not incremented)
Index: shadow-4.0.12/src/su.c
===================================================================
--- shadow-4.0.12.orig/src/su.c	2005-08-29 21:45:05.000000000 +0200
+++ shadow-4.0.12/src/su.c	2005-08-29 21:46:17.000000000 +0200
@@ -31,6 +31,7 @@
 
 #include "rcsid.h"
 RCSID (PKG_VER "$Id: su.c,v 1.41 2005/08/04 19:13:43 kloczek Exp $")
+#include <getopt.h>
 #include <grp.h>
 #include <pwd.h>
 #include <signal.h>
@@ -76,6 +77,18 @@
 
 /* local function prototypes */
 
+/* If nonzero, change some environment vars to indicate the user su'd to.  */
+static int change_environment;
+
+static struct option const longopts[] =
+{
+  {"command", required_argument, 0, 'c'},
+  {"preserve-environment", no_argument, 0, 'p'},
+  {"shell", required_argument, 0, 's'},
+  {"help", no_argument, 0, 'h'},
+  {0, 0, 0, 0}
+};
+
 #ifndef USE_PAM
 
 static RETSIGTYPE die (int);
@@ -259,6 +272,8 @@
 	uid_t my_uid;
 	struct passwd *pw = 0;
 	char **envp = environ;
+	char *command = 0, *shell = 0, **additional_args = 0;
+	int optc;
 
 #ifdef USE_PAM
 	int ret;
@@ -279,6 +294,8 @@
 	bindtextdomain (PACKAGE, LOCALEDIR);
 	textdomain (PACKAGE);
 
+	change_environment = 1;
+
 	/*
 	 * Get the program name. The program name is used as a prefix to
 	 * most error messages.
@@ -322,15 +339,56 @@
 	 * Process the command line arguments. 
 	 */
 
-	argc--;
-	argv++;			/* shift out command name */
+	while ((optc = getopt_long (argc, argv, "c:mps:h", longopts, NULL)) != -1) {
+		switch (optc) {
+		    case 0:
+			break;
+		    case 'c':
+			command = optarg;
+			break;
+		    case 'm':
+		    case 'p':
+			change_environment = 0;
+			break;
+		    case 's':
+			shell = optarg;
+			break;
+		    default:
+			fprintf(stderr, _("\
+Usage: su [OPTS] [-] [username [ARGS]]\n\
+	-	make this a login shell\n\
+	-c, --command=<command>\n\
+		pass command to the invoked shell using its -c\n\
+		option\n\
+	-m, -p, --preserve-environment\n\
+		do not reset environment variables, and keep the\n\
+		same shell\n\
+	-s, --shell=<shell>\n\
+		use shell instead of the default in /etc/passwd\n"));
+			exit(1);
+		}
+	}
 
-	if (argc > 0 && strcmp (argv[0], "-") == 0) {
+	if (optind < argc && !strcmp (argv[optind], "-")) {
 		fakelogin = 1;
-		argc--;
-		argv++;		/* shift ... */
+		++optind;
+	}
+
+	if (optind < argc)
+		strncpy(name, argv[optind++], sizeof(name) - 1);
+	else {
+		struct passwd *root_pw = getpwuid(0);
+		if (root_pw == NULL) {
+			SYSLOG((LOG_CRIT, "There is no UID 0 user."));
+			su_failure(tty);
+		}
+		strcpy(name, root_pw->pw_name);
 	}
 
+	if (optind < argc)
+		additional_args = argv + optind;
+
+
 	/*
 	 * If a new login is being set up, the old environment will be
 	 * ignored and a new one created later on.
@@ -365,29 +423,7 @@
 			addenv (*envp++, NULL);
 	}
 
-	/*
-	 * The next argument must be either a user ID, or some flag to a
-	 * subshell. Pretty sticky since you can't have an argument which
-	 * doesn't start with a "-" unless you specify the new user name.
-	 * Any remaining arguments will be passed to the user's login shell.
-	 */
-
-	if (argc > 0 && argv[0][0] != '-') {
-		STRFCPY (name, argv[0]);	/* use this login id */
-		argc--;
-		argv++;		/* shift ... */
-	}
-	if (!name[0])		/* use default user ID */
-	{
-		struct passwd *root_pw = getpwuid(0);
-		if (root_pw == NULL) {
-			SYSLOG((LOG_CRIT, "There is no UID 0 user."));
-			su_failure(tty);
-		}
-		strcpy(name, root_pw->pw_name);
-	}
-
-	doshell = argc == 0;	/* any arguments remaining? */
+	doshell = optind == argc;	/* any arguments remaining? */
 
 	/*
 	 * Get the user's real name. The current UID is used to determine
@@ -509,6 +545,23 @@
 	if (pwent.pw_shell[0] == '\0')
 		pwent.pw_shell = "/bin/sh";	/* XXX warning: const */
 
+	/* If the user do not want to change the environment,
+	 * use the current SHELL.
+	 * (unless another shell is required by the command line)
+	 */
+	if (shell == 0 && change_environment == 0)
+		shell = getenv ("SHELL");
+	/* For users whith non null UID, if this user has a restricted
+	 * shell, the shell must be the one specified in /etc/passwd
+	 */
+	if (shell != 0 && getuid () && restricted_shell (pwent.pw_shell))
+		shell = 0;
+	/* If the shell is not set at this time, use the shell specified
+	 * in /etc/passwd.
+	 */
+	if (shell == 0)
+		shell = (char *) strdup (pwent.pw_shell);
+
 	signal (SIGINT, SIG_IGN);
 	signal (SIGQUIT, SIG_IGN);
 #ifdef USE_PAM
@@ -687,7 +740,7 @@
 	else {
 		addenv ("HOME", pwent.pw_dir);
 		addenv ("USER", pwent.pw_name);
-		addenv ("SHELL", pwent.pw_shell);
+		addenv ("SHELL", shell);
 	}
 #endif
 

Goal: 
     * need restricted_shell() for --preserve-environment
     * run_shell has to be available when !USE_PAM
     * for -c, we need to add arguments. It is safer to allocate a new
       array than using argv. We need the elements() function to compute the
       number of additional arguments.
     * arg0 is computed in run_shell.
     * There is no more need for doshell. We know that we only need to
       execute a shell when there is no additional arguments.
Index: shadow-4.0.13/src/su.c
===================================================================
--- shadow-4.0.13.orig/src/su.c	2005-10-04 08:07:15.966077788 +0200
+++ shadow-4.0.13/src/su.c	2005-10-04 08:07:16.698928465 +0200
@@ -127,6 +127,24 @@
 }
 #endif				/* !USE_PAM */
 
+/* borrowed from GNU sh-utils' "su.c" */
+static int
+restricted_shell (const char *shell)
+{
+	char *line;
+
+	setusershell ();
+	while ((line = getusershell ()) != NULL) {
+		if (*line != '#' && strcmp (line, shell) == 0) {
+			endusershell ();
+			return 0;
+		}
+	}
+	endusershell ();
+	return 1;
+}
+
+
 
 static void su_failure (const char *tty)
 {
@@ -149,23 +167,70 @@
 {
 	++caught;
 }
+#endif
+
+/* borrowed from GNU sh-utils' "su.c" */
+static int elements (char **arr)
+{
+	int n = 0;
+	if (arr)
+		for (n = 0; *arr; ++arr)
+			++n;
+
+	return n;
+}
 
 /* This I ripped out of su.c from sh-utils after the Mandrake pam patch
  * have been applied.  Some work was needed to get it integrated into
  * su.c from shadow.
  */
-static void run_shell (const char *shellstr, char *args[], int doshell)
+static void run_shell (const char *shellstr, char **additional_args, int fakelogin)
 {
+	const char **args;
 	int child;
 	sigset_t ourset;
 	int status;
 	int ret;
+	int argno = 0;
+
+	args = (const char **)xmalloc(sizeof (char *)
+	                              * (2 + elements (additional_args)));
 
+	if (fakelogin) {
+		char *arg0;
+		char *shell_basename;
+
+		shell_basename = getdef_str ("SU_NAME");
+		if (!shell_basename)
+			shell_basename = Basename (shellstr);
+
+		arg0 = xmalloc (strlen (shell_basename) + 2);
+		arg0[0] = '-';
+		strcpy (arg0 + 1, shell_basename);
+		args[0] = arg0;
+	} else
+		args[0] = Basename (shellstr);
+	argno = 1;
+
+	if (additional_args) {
+		for (; *additional_args; ++additional_args) {
+			args[argno++] = *additional_args;
+		}
+	}
+	args[argno] = NULL;
+
+#ifndef USE_PAM
+	if (argno > 1)
+		(void) execv (shellstr, args);
+	else
+		shell (shellstr, args[0]);
+	/* NOT REACHED */
+#else
 	child = fork ();
 	if (child == 0) {	/* child shell */
 		pam_end (pamh, PAM_SUCCESS);
 
-		if (doshell)
+		if (argno == 1)
 			shell (shellstr, (char *) args[0]);
 		else
 			(void) execv (shellstr, (char **) args);
@@ -243,8 +308,8 @@
 	}
 
 	exit (WEXITSTATUS (status));
+#endif	/* USE_PAM */
 }
-#endif
 
 /*
  * su - switch user id
@@ -264,7 +329,6 @@
 	char *cp;
 	char **envcp;
 	const char *tty = 0;	/* Name of tty SU is run from        */
-	int doshell = 0;
 	int fakelogin = 0;
 	int amroot = 0;
 	uid_t my_uid;
@@ -384,7 +448,6 @@
 	if (optind < argc)
 		additional_args = argv + optind;
 
-
 	/*
 	 * If a new login is being set up, the old environment will be
 	 * ignored and a new one created later on.
@@ -420,8 +483,6 @@
 			addenv (*envp++, NULL);
 	}
 
-	doshell = optind == argc;	/* any arguments remaining? */
-
 	/*
 	 * Get the user's real name. The current UID is used to determine
 	 * who has executed su. That user ID must exist.
@@ -746,45 +807,7 @@
 	 */
 	closelog ();
 
-	/*
-	 * See if the user has extra arguments on the command line. In that
-	 * case they will be provided to the new user's shell as arguments.
-	 */
-	if (fakelogin) {
-		char *arg0;
-
-		cp = getdef_str ("SU_NAME");
-		if (!cp)
-			cp = Basename (pwent.pw_shell);
-
-		arg0 = xmalloc (strlen (cp) + 2);
-		arg0[0] = '-';
-		strcpy (arg0 + 1, cp);
-		cp = arg0;
-	} else
-		cp = Basename (pwent.pw_shell);
-
-	if (!doshell) {
-		/*
-		 * Use new user's shell from /etc/passwd and create an argv
-		 * with the rest of the command line included.
-		 */
-		argv[-1] = pwent.pw_shell;
-#ifndef USE_PAM
-		(void) execv (pwent.pw_shell, &argv[-1]);
-#else
-		run_shell (pwent.pw_shell, &argv[-1], 0);
-#endif
-		(void) fprintf (stderr, _("No shell\n"));
-		SYSLOG ((LOG_WARN, "Cannot execute %s", pwent.pw_shell));
-		closelog ();
-		exit (1);
-	}
-#ifndef USE_PAM
-	shell (pwent.pw_shell, cp);
-#else
-	run_shell (pwent.pw_shell, &cp, 1);
-#endif
+	run_shell (shell, additional_args, fakelogin);
 	/* NOT REACHED */
 	exit (1);
 }
